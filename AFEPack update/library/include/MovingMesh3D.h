/**
 * @file   MovingMesh3D.h
 * @author Yana Di, Ruo Li
 * @date   Thu Dec 22 10:06:31 2005
 * 
 * @brief  declaration of class MovingMesh3D
 * 
 * 
 */

#ifndef __MovingMesh3D_h__
#define __MovingMesh3D_h__

#include <lac/sparsity_pattern.h>
#include <lac/sparse_matrix.h>
#include "AMGSolver.h"
#include "Geometry.h"

AFEPACK_OPEN_NAMESPACE

/**
 * definition of class MovingMesh3D. This class support only the mesh data
 * generated by gmesh. It can serve as a 3D tetrahedron mesh and the mesh
 * nodes are moving according a given monitor function. To implement a
 * problem solver based on moving mesh, the FEM space can be built on 
 * this mesh and if the virtual method Monitor is given, the mesh will 
 * move according this monitor. Another virtual method updateSolution
 * should also be implemented in the derived class that the solution can
 * be correctly updated on the moving mesh.
 */
class MovingMesh3D : public Mesh<3,3>
{
 public:
  typedef GeometryBM::bmark_t bound_t;
  struct Vertex : public Point<3> {
    int index;
    bound_t boundary_mark;
  };
  struct Edge {
    int index;
    int vertex[2];
    bound_t boundary_mark;
  };
  struct Surface {
    int index;
    u_int n_edge;
    std::vector<int> edge;
    bound_t boundary_mark;
    double normal[3]; /**< normal of the surface */
    double logic_normal[3]; /**< normal of the surface on logical domain */
  };
  struct Domain {
    u_int n_vertex;
    u_int n_edge;
    u_int n_surf;
    std::vector<Vertex> physical_domain_vertex;
    std::vector<Vertex> logical_domain_vertex;
    std::vector<Edge> edge;
    std::vector<Surface> surface;
  };

  class Solver { /**< 特殊设计的代数多重网格求解器来求解网格方程 */
  protected:
    bool					is_initialized;
    int						n_project;
    std::vector<SparseMatrix<double> *>		project_matrix;
    std::vector<SparseMatrix<double> *>	        project_matrix_r;
    std::vector<SparseMatrix<double> *>	        projected_matrix;
    std::vector<const std::vector<int> *>	boundary_mark;
    u_int					smooth_step;
    u_int					min_order;
    const Domain *                              domain;
  public:
    Solver();
    ~Solver();
  public:
    u_int smoothStep() const {return smooth_step;}
    u_int& smoothStep() {return smooth_step;}
    u_int minimalOrder() const {return min_order;}
    u_int& minimalOrder() {return min_order;}

    void reinit(SparseMatrix<double>&,
		const std::vector<int>&,
		const Domain&);
    void clear();
    void solve(std::vector<Vector<double> >& x, 
	       const std::vector<Vector<double> >& r,
	       u_int steps = 5) const;
  private:
    void Project(const SparseMatrix<double>& M,
		 const std::vector<int>& bm,
		 SparseMatrix<double> *& P, 
		 SparseMatrix<double> *& PMPT,
		 SparseMatrix<double> *& Pt, 
		 std::vector<int> *& pbm);
    void Init(SparseMatrix<double>&,
	      const std::vector<int>&,
	      const Domain&);
    void GaussSidel(const SparseMatrix<double>& M, 
		    std::vector<Vector<double> >& x, 
		    const std::vector<Vector<double> >& r,
		    const std::vector<int>& bm,
		    const u_int& s) const;
    SparseMatrix<double> * getPMPT(const SparseMatrix<double> & P, 
				   const SparseMatrix<double> & M,
				   const SparseMatrix<double> & Pt) const;
    void lazyPMPT(const SparseMatrix<double>& P, 
		  const SparseMatrix<double>& M,
		  const SparseMatrix<double>& Pt,
		  SparseMatrix<double>& A) const;
  };


 private:
  Domain domain;
  std::vector<Point<3> > logical_node;
  double move_step_length;
  u_int n_move_step;
  std::vector<Point<3> > move_direction;
  std::vector<Point<3> > logical_move_direction;
  std::vector<float> mon;

  u_int n_interior_node;
  u_int n_boundary_node;
  std::vector<int> index;
  std::vector<u_int> interior_node_index;
  std::vector<u_int> boundary_node_index;
  u_int n_boundary_constraint;
  std::vector<int> boundary_mark;

  SparsityPattern spM;
  SparseMatrix<double> M;
  Solver solver;

  static int primes[]; /// 素数表
  u_int solve_step;
  double tol;

 public:
  MovingMesh3D();
  virtual ~MovingMesh3D();

 public:
  const std::vector<float>& monitor() const {return mon;};
  std::vector<float>& monitor() {return mon;};
  const float& monitor(const u_int& i) const {return mon[i];};
  float& monitor(const u_int& i) {return mon[i];}

  const std::vector<Point<3> >& moveDirection() const {return move_direction;};
  std::vector<Point<3> >& moveDirection() {return move_direction;};
  const Point<3>& moveDirection(const u_int& i) const {return move_direction[i];};
  Point<3>& moveDirection(const u_int& i) {return move_direction[i];};
	
  std::vector<double> moveDirection(const Point<3>& point, 
                                    const int& element) const;
  std::vector<std::vector<double> > moveDirection(const std::vector<Point<3> >& point, 
                                                  const int& element) const;
  double moveDirectionDivergence(const u_int& element) const;

  double moveStepLength() const {return move_step_length;};
  double& moveStepLength() {return move_step_length;};

  u_int moveStep() const {return n_move_step;};
  u_int& moveStep() {return n_move_step;};
	
  u_int solveStep() const {return solve_step;}
  u_int& solveStep() {return solve_step;}

  double tolerence() const {return tol;}
  double& tolerence() {return tol;}
	
  void moveMesh();
  void outputPhysicalMesh(const std::string& file);
  void outputLogicalMesh(const std::string& file);
  virtual void getMonitor();
  virtual void smoothMonitor(u_int step = 1);
  virtual void updateMesh();
  virtual void updateSolution() = 0;
  virtual void outputSolution() = 0;
  virtual void getMoveStepLength();
  void readDomain(const std::string& file);

 private:
  void getLogicalMesh();
  void getMoveDirection();
  void readDummy(std::ifstream& is);
  void parseBoundary();
};

AFEPACK_CLOSE_NAMESPACE

#endif /**< __MovingMesh3D_h__ */

/**
 * end of file
 * 
 */

