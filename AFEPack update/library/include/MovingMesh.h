/**
 * @file   MovingMesh.h
 * @author Robert Lie
 * @date   Mon May 28 23:06:29 2007
 * 
 * @brief  
 * 
 * 
 */

#ifndef __MovingMesh_h__
#define __MovingMesh_h__

#warning "This file is obsolete and will not be maintained any more! \
Please use MovingMesh2D.h instead! \
注意：这个类的算法在最近进行了比较大的改进，已经被更新为MovingMesh2D， \
请以后的程序尽量基于这个新的类进行开发，这个类本身将不会进一步维护， \
并在一个时期以后会被废弃。"

#include <lac/precondition.h>
#include <lac/sparse_ilu.h>
#include <lac/solver_control.h>
#include <lac/solver_gmres.h>
#include <lac/vector_memory.h>

#include "AMGSolver.h"
#include "Geometry.h"
#include "EasyMesh.h"

AFEPACK_OPEN_NAMESPACE

/**
 * definition of class MovingMesh. This class support only the mesh data
 * generated by easymesh. It can serve as a 2D triangle mesh and the mesh
 * nodes are moving according a given monitor function. To implement a
 * problem solver based on moving mesh, the FEM space can be built on 
 * this mesh and if the virtual method Monitor is given, the mesh will 
 * move according this monitor. Another virtual method updateSolution
 * should also be implemented in the derived class that the solution can
 * be correctly updated on the moving mesh.
 *
 * In the directory example/moving_mesh, there is a typical example to
 * use this class to solve a viscous Burgers equation using moving mesh
 * method. 
 *
 * 重要：这个类的算法在最近进行了比较大的改进，已经被更新为MovingMesh2D， 
 * 请以后的程序尽量基于这个新的类进行开发，这个类本身将不会进一步维护，
 * 并在一个时期以后会被废弃。
 *
 */
class MovingMesh : public EasyMesh
{
public:
	typedef GeometryBM::bmark_t bmark_t;
	struct Vertex : public Point<2> {
		int index;
		bmark_t boundary_mark;
	};
	struct Edge {
		int index;
		int vertex[2];
		bmark_t boundary_mark;
	};
	struct Domain {
		int n_vertex;
		int n_edge;
		std::vector<Vertex> physical_domain_vertex;
		std::vector<Vertex> logical_domain_vertex;
		std::vector<Edge> edge;
	};
private:
	Domain domain;
	std::vector<Point<2> > logical_node;
	double move_step_length;
	int n_move_step;
	std::vector<Point<2> > move_direction;
	std::vector<Point<2> > logical_move_direction;
	std::vector<float> mon;

	int n_interior_node;
	int n_boundary_node;
	std::vector<int> index;
	std::vector<int> interior_node_index;
	std::vector<int> boundary_node_index;
	std::vector<int> face_index;
	int n_boundary_face;
	std::vector<int> boundary_face;
	std::vector<std::vector<int> > mb_node;
	std::vector<std::vector<int> > mb_face;
	int n_boundary_constraint;

	SparsityPattern spM;
	SparsityPattern spN;
	SparsityPattern spMb;
public:
	MovingMesh();
	virtual ~MovingMesh();
public:
	const std::vector<float>& monitor() const {return mon;};
	std::vector<float>& monitor() {return mon;};
	const float& monitor(const int& i) const {return mon[i];};
	float& monitor(const int& i) {return mon[i];}
	const std::vector<Point<2> >& moveDirection() const {return move_direction;};
	std::vector<Point<2> >& moveDirection() {return move_direction;};
	const Point<2>& moveDirection(const int& i) const {return move_direction[i];};
	Point<2>& moveDirection(const int& i) {return move_direction[i];};
	
	std::vector<double> moveDirection(const Point<2>& point, const int& element) const;
	std::vector<std::vector<double> > moveDirection(const std::vector<Point<2> >& point, const int& element) const;
	double moveDirectionDivergence(const int& element) const;
	const double& moveStepLength() const {return move_step_length;};
	double& moveStepLength() {return move_step_length;};
	const int& n_moveStep() const {return n_move_step;};
	int& n_moveStep() {return n_move_step;};
	
	void moveMesh();
	void outputPhysicalMesh(const std::string& file);
	void outputLogicalMesh(const std::string& file);
	virtual void getMonitor();
	virtual void smoothMonitor(int step = 1);
	virtual void updateMesh();
	virtual void updateSolution() = 0;
	virtual void outputSolution() = 0;
	virtual void getMoveStepLength();
	void readDomain(const std::string& file);
private:
	void getLogicalMesh();
	void getMoveDirection();
	void readDummy(std::ifstream& is);
	void parseBoundary();
};

AFEPACK_CLOSE_NAMESPACE

#endif // __MovingMesh_h__

/**
 * end of file
 * 
 */


